# Spring batch + scheduler

<aside>
💡 Spring boot에서 배치와 스케줄러를 사용하여 데이터베이스를 자동으로 처리하는 방법을 배운다.

</aside>

**목차**

# 문제 정의

앱에서 주기적으로 회원들의 마지막 접속일에서 지난 시간을 확인하여 일정 시간동안 접속을 하지 않았을 경우 회원들의 상태를 INACTIVE 상태로 변경하게 만들어야 한다.

# 기본 개념

## 스프링 배치

스프링 배치의 정의는?

- 스프링 배치(Spring Batch)는 대량의 데이터를 처리하고, 관리할 수 있는 프레임워크이다. 스프링 배치는 스프링 프레임 워크를 기반으로 구축되었고, 배치 작업을 개발할때 필요한 많은 반복적인 작업을 줄여준다. 배치 작업은 일반적으로 정해진 양의 데이터를 처리하고, 일정 기간마다 반복적으로 실행되는 작업을 의미한다.
    
    세부 사항을 추가하세요
    

여기서 사용할 배치 프레임워크의 기본적인 구조는?

- JobLauncher: 배치 작업(Job)을 시작하는 데 사용된다. 실행할 Job과 매개변수를 받아 작업을 실행한다.
    
    

                                이후 스케줄러로 주기적 작업을 하는데 사용될 예정이다.

- Job: 배치 처리의 전체 프로세서를 정의하는 컨테이너이다. 하나 이상의 Step을 포함할 수 있다.
- Step: 일반적으로 배치 처리 시스템에서 개별적인 작업 단위를 의미한다. 하나의 Step은 데이터를 읽고(Reader), 처리하고(Processor), 그리고 쓰는(Writer) 과정을 모두 포함할 수 있다.
- ItemReader: 데이터 소스에서 데이터를 읽어오는 역할을 한다.
- ItemProcessor: 읽어온 데이터를 가공하거나 변환하는 작업을 수행한다.
- ItemWriter: 가공된  데이터를 최종적으로 저장하거나 다른 시스템으로 전송한다.
- JobRepository: Job의 실행 관련 정보를 저장하는 데이터 베이스로, Job의 상태, 실행 이력들을 관리한다.

![Untitled](Spring%20batch%20+%20scheduler%20bc64f044e60f4fb89703af66387515b0/Untitled.png)

## 스케줄러

스프링 스케줄러의 정의 및 역할은?

- 스프링 스케줄러는 스프링 프레임워크의 일부로, 메서드를 정해진 시간이나 간격에 따라 실행할 수 있도록 도와준다.  스프링 배치와 함께 스프링 스케줄러를 사용하면 배치 Job을 자동화하고 일정에 따라 실행할 수 있다. 이를 통해 배치 Job을 예약하고 관리하는 과정을 간소화할 수 있다.
    

    

스케줄러 방식은?

- **Task Scheduling**: 스프링 스케줄러를 사용하면 특정 시간에 메서드를 실행하도록 예약할 수 있습니다. 이는 주로 `@Scheduled` 어노테이션을 메서드 위에 선언하여 사용한다.
    

    
- **Cron Expression**: 스프링 스케줄러는 UNIX 시스템의 cron과 유사한 형식을 사용하여 작업 실행 시간을 지정할 수 있다. 이 표현식을 통해 복잡한 스케줄링 요구 사항을 정의할 수 있다.
- **Fixed Rate and Fixed Delay**: 스프링 스케줄러는 고정된 주기(fixed rate)나 작업 완료 후 고정된 지연 시간(fixed delay)을 설정하여 주기적으로 작업을 실행할 수 있게 해준다.

```java
@Component
public class ScheduledTasks {
    @Scheduled(cron = "0 15 10 15 * ?")  // 매월 15일 오전 10시 15분에 실행
    public void monthlyTask() {
        System.out.println("Executing monthly task");
    }

    @Scheduled(fixedRate = 5000)  // 시작 시간으로부터 5초마다 실행
    public void fixedRateTask() {
        System.out.println("Running fixed rate task");
    }

    @Scheduled(fixedDelay = 10000, initialDelay = 5000)  // 첫 실행 후 5초 지연, 그 후 작업 완료 후 10초마다 실행
    public void fixedDelayTask() {
        System.out.println("Running fixed delay task");
    }
}

```

# 실습

## 스프링 배치

Step1) Spring batch IO라는 dependency 설정하기

- 종속성을 넣는다.

    ```
    <!-- https://mvnrepository.com/artifact/org.springframework.batch/spring-batch-core -->
    <dependency>
        <groupId>org.springframework.batch</groupId>
        <artifactId>spring-batch-core</artifactId>
        <version>5.1.2</version>
    </dependency>
    ```

    
  
    

Step2) Spring Batch 플러그인 설치하기- dependency를 설정하면 설치하라는 문구가 뜬다.

![Untitled](Spring%20batch%20+%20scheduler%20bc64f044e60f4fb89703af66387515b0/Untitled%201.png)

Step3) 어플리케이션 실행 클래스에 @EnableBatchProcessing 어노테이션을 붙여준다.(중요)

- 예시:
    
   
    

```java
@SpringBootApplication
@EnableBatchProcessing
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
    
}
```

Step4) 베치에 필요한 데이터 테이블을 생성한다.

- 목표는 배치를 통해 데이터 베이스를 처리하는 것인데 이를 위해서는 몇개의 데이터 테이블을 생성해 놓아야한다. 테이블들에는 Job의 이름, 실행 시간, job_id나 Step의 이름, 실행시간, step_id 등 배치를 실행했을때 생성되는 데이터 들이 들어가게 된다. (없으면 실행이 안됌)
    
    
    
- 생성해야 하는 테이블을 생성하는 sql문의 경로는 /org/springframework/batch/spring-batch-core/5.1.2/spring-batch-core-5.1.2.jar!/org/springframework/batch/core/schema-mysql.sql이다. 아래에 폴더를 열면 있는 파일을 클릭하면 테이블을 생성하는 sql문이 있다. 그걸 실행해서 테이블을 생성하면 된다.

폴더)

![Untitled](Spring%20batch%20+%20scheduler%20bc64f044e60f4fb89703af66387515b0/Untitled%202.png)

파일)

![Untitled](Spring%20batch%20+%20scheduler%20bc64f044e60f4fb89703af66387515b0/Untitled%203.png)

내부 내용) 

```sql
-- Autogenerated: do not edit this file

CREATE TABLE BATCH_JOB_INSTANCE  (
	JOB_INSTANCE_ID BIGINT  NOT NULL PRIMARY KEY ,
	VERSION BIGINT ,
	JOB_NAME VARCHAR(100) NOT NULL,
	JOB_KEY VARCHAR(32) NOT NULL,
	constraint JOB_INST_UN unique (JOB_NAME, JOB_KEY)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION  (
	JOB_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
	VERSION BIGINT  ,
	JOB_INSTANCE_ID BIGINT NOT NULL,
	CREATE_TIME DATETIME(6) NOT NULL,
	START_TIME DATETIME(6) DEFAULT NULL ,
	END_TIME DATETIME(6) DEFAULT NULL ,
	STATUS VARCHAR(10) ,
	EXIT_CODE VARCHAR(2500) ,
	EXIT_MESSAGE VARCHAR(2500) ,
	LAST_UPDATED DATETIME(6),
	constraint JOB_INST_EXEC_FK foreign key (JOB_INSTANCE_ID)
	references BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_PARAMS  (
	JOB_EXECUTION_ID BIGINT NOT NULL ,
	PARAMETER_NAME VARCHAR(100) NOT NULL ,
	PARAMETER_TYPE VARCHAR(100) NOT NULL ,
	PARAMETER_VALUE VARCHAR(2500) ,
	IDENTIFYING CHAR(1) NOT NULL ,
	constraint JOB_EXEC_PARAMS_FK foreign key (JOB_EXECUTION_ID)
	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION  (
	STEP_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
	VERSION BIGINT NOT NULL,
	STEP_NAME VARCHAR(100) NOT NULL,
	JOB_EXECUTION_ID BIGINT NOT NULL,
	CREATE_TIME DATETIME(6) NOT NULL,
	START_TIME DATETIME(6) DEFAULT NULL ,
	END_TIME DATETIME(6) DEFAULT NULL ,
	STATUS VARCHAR(10) ,
	COMMIT_COUNT BIGINT ,
	READ_COUNT BIGINT ,
	FILTER_COUNT BIGINT ,
	WRITE_COUNT BIGINT ,
	READ_SKIP_COUNT BIGINT ,
	WRITE_SKIP_COUNT BIGINT ,
	PROCESS_SKIP_COUNT BIGINT ,
	ROLLBACK_COUNT BIGINT ,
	EXIT_CODE VARCHAR(2500) ,
	EXIT_MESSAGE VARCHAR(2500) ,
	LAST_UPDATED DATETIME(6),
	constraint JOB_EXEC_STEP_FK foreign key (JOB_EXECUTION_ID)
	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_CONTEXT  (
	STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
	SHORT_CONTEXT VARCHAR(2500) NOT NULL,
	SERIALIZED_CONTEXT TEXT ,
	constraint STEP_EXEC_CTX_FK foreign key (STEP_EXECUTION_ID)
	references BATCH_STEP_EXECUTION(STEP_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_JOB_EXECUTION_CONTEXT  (
	JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
	SHORT_CONTEXT VARCHAR(2500) NOT NULL,
	SERIALIZED_CONTEXT TEXT ,
	constraint JOB_EXEC_CTX_FK foreign key (JOB_EXECUTION_ID)
	references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
) ENGINE=InnoDB;

CREATE TABLE BATCH_STEP_EXECUTION_SEQ (
	ID BIGINT NOT NULL,
	UNIQUE_KEY CHAR(1) NOT NULL,
	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_STEP_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_STEP_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_EXECUTION_SEQ (
	ID BIGINT NOT NULL,
	UNIQUE_KEY CHAR(1) NOT NULL,
	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_JOB_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_EXECUTION_SEQ);

CREATE TABLE BATCH_JOB_SEQ (
	ID BIGINT NOT NULL,
	UNIQUE_KEY CHAR(1) NOT NULL,
	constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
) ENGINE=InnoDB;

INSERT INTO BATCH_JOB_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_SEQ);
```

Step4) 기본적인 Job파일을 세팅한다.(설명 주석으로한다.)

- 예시:
    
    세부 사항을 추가하세요
    

```java

@RequiredArgsConstructor
@Configuration
public class BatchConfiguration {
    private final EntityManagerFactory entityManagerFactory;
    private final PlatformTransactionManager transactionManager;
    //EntityManagerFactory, transactionManager를 주입받아야한다.
    @Bean
    public Job job(JobRepository jobRepository, Step step){
        return new JobBuilder("simpleJob", jobRepository)
        //JobBuilder를 통해 Job을 생성한다.(job의 이름을 입력하고, jobrepository를 넣는다.)
        .start(step)
        //시작할 step을 설정해준다. 스텝이 2개이상일경우 .next(nextstep)으로 이어간다.
        .build();
        //생성한다.
    }
    //jobbuilder로 생성한것을 빈으로 등록해준다.
    @Bean
    public Step read_akstep(JobRepository jobRepository){
        return new StepBuilder("step", jobRepository)
        //StepBuilder로 Step을 생성한다.(step의 이름을 입력하고, jobrepository를 넣는다.)
                .<Member, Member>chunk(10, transactionManager)
                //IO되는 entity를 넣어주고 chunk와 transactionManager를 넣어준다.
                //여기서 chunk를 10으로 넣어주면 10개씩 가져온다는 뜻이다. 
                .reader(reader())
                //가져오는 reader를 설정해준다.
                .processor(processor())
                //가져온다음 데이터를 처리하는 processor를 설정해준다.
                .writer(writer())
                //다시 데이터를 넣는 writer를 설정해준다.
                .build();
    }
    @Bean
    public JpaPagingItemReader<Member> reader(){
        return new JpaPagingItemReaderBuilder<Member>()
                .name("jpapagingreader")
                //reader의 이름을 설정해 준다.
                .entityManagerFactory(entityManagerFactory)
                //entitymanagerfactory를 넣어준다.
                .queryString("SELECT m FROM Member m ORDER BY m.id ASC")
                //가져오는 쿼리문을 작성한다.
                .build();
    }
    @Bean
    public ItemProcessor<Member, Member> processor(){
        return (member-> {
            ZonedDateTime now = ZonedDateTime.now();
            long yearsDifference = ChronoUnit.YEARS.between(now, member.getLast_login_date());
            //지금현재시간과 멤버의 마지막 접속일의 차이를 구한다.
            if(yearsDifference >= 1){
                member.setStatus(Status.Inactive);
                return member;
                //1년이상 차이날 때 들어온 member의 상태를 INACTIVE로 바꿔주고 멤버를 반환한다.
            }else{
                return member;
                //1년이 안되었으면 들어온 member를 그대로 반환한다.
            }
        });
    }
    @Bean
    public JpaItemWriter<Member> writer(){
        JpaItemWriter<Member> writer = new JpaItemWriter<Member>();
        writer.setEntityManagerFactory(entityManagerFactory);
        //writer의 entitymanagerfactory를 설정해준다.
        return writer;
    }

}

```

## 스케줄러

Step1) 애플리케이션 실행 클래스에 @EnableScheduling 을 설정해준다.

```java
@SpringBootApplication
@EnableBatchProcessing
@EnableScheduling
public class Application {

    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }

}
```

Step2) 스케줄러로 설정하여 joblauncher가 매일 00시 마다 전에 설정해둔 job을 실행하게끔 해준다.(설명 주석으로)

```java
@Component
public class ScheduleTask {
    @Autowired
    private JobLauncher jobLauncher;
    @Autowired
    private Job job;
    //jobLauncher와 job을 주입받아야한다.
    @Scheduled(cron = "0 0 0 * * ?")
    //0초에 시작-0분에 시작-0시에시작-모든날짜에 실행-모든 월에 실행-?특정요일 지정하지 않음
		//일과 요일은 서로 충돌할 수 있으므로 하나를 지정하고 다른 하나는 '?'로 설정)
    public void reportCurrentTime(){
        try{
            JobParameters jobParameters = new JobParametersBuilder()
                    .addLong("time", System.currentTimeMillis())
                    .toJobParameters();
                    //jobparameter는 사용하지 않지만 밑에 주의점 때문에 필요함.
            jobLauncher.run(job, jobParameters);
            //job과 jobParameters를 넣어주고 실행한다.
        }catch(Exception e){
            e.printStackTrace();
        }
    }

}
```

# *주의점*

스프링 배치와 같은 배치 처리 시스템에서는 일반적으로 같은 `JobParameters`로 작업을 다시 실행할 수 없다. 즉, 한 번 실행된 작업을 동일한 파라미터로 재실행하려고 하면 에러가 발생할 수 있다. 이는 스프링 배치가 동일한 파라미터로 실행된 작업을 동일한 실행으로 간주하기 때문이다.
