# 최종 면담

# 📍 CI/CD 및 아키텍쳐

### ✔️ Jenkins 문제점

- ssh id 한 개당 젠킨스 한 개만 할당이 가능함 → 여러 계정이 필요
- 현업에서는 젠킨스를 훨씬 더 많이 씀 깃 액션이 편하지만 .. 외부에 드러남 → 보안 문제
    - 보안을 생각하고 구현한다고 하면 ci/cd 측에 아무나 접근이 가능하면 보안 이슈가 일어남
    - 해당 ip에서만 작동할 수 있도록 구현해야 하는데 깃 액션은 불가능

### ✔️ CI/CD 구축하는 이유

- 하나하나 명령어 치는 것이 어려워서? 자동화하는게 정확성도 높이고 속도/시간 절약 가능
- 결국은 안정성때문에.. 배포하는 과정이 호락호락하지 않음
- 이런걸 자동화해야 배포 과정에서 실수를 줄일 수 있음
    - 정부24 문제 찾아보기
- 어떤 서비스를 만드는 것도 중요하지만 배포 과정이 매우 중요함 (무중단 배포)

### ✔️ 아키텍쳐

- 클라이언트가 nginx를 통해 프론트1,2로 로드밸런싱
    - 무중단 배포 과정 설명 : 무중단 배포할 때 배포하면 sleep을 줘서
    - 도커에서 상태값 체크해서 → 프론트1이 러닝되는 순간 프론트2가 배포가 되도록?
        - 도커는 분명 애플리케이션 구동으로 뜨는데 막상 호출하니 반응 x → 서버의 상태도 알아야 함 (스프링 액츄에이터?)
        - 프론트2를 배포하면 프론트1쪽으로 요청을 몰아줘야하는데 이 과정에서 nginx 설정이 있는지?
        - 딱히 설정은 안했고 nginx config에서 모든 설정을 1/2로 들어가게끔 설정
            - 그럼 장애가 발생할 수 있지 않나?
        - nginx에서 서버 그룹을 빼라.. ? ?
- 중간에 게이트웨이 → 백엔드를 보면 내부 로드 밸런싱이 있는데 (이걸 보면 L4를 쓴건가? 안써도 되는?)
    - 스프링 클라우드 내부에서 자동적으로 로드 밸런싱해줘서 넣었음 → 착각할 수 있으니 삭제하던가
- 안에 페이코..토스..소나큐브… 너무 많음 강조해야할게 따로 있음 → 너무 혼잡
    - 기술들 아이콘밖에 안보임
- 인증 서버 같은 경우 → 강조해야할 것은 인증 서버. auth란 인증 서버를 강조해야함
- 아키텍쳐 그림을 단순화.. 주객전도 된거 같음 → 안에 쓰는 기술들이 너무 강조됨
- 게이트웨이 → 게이트웨이에서 장애 생길 듯..?
- 유레카 스프링 클라우드가 어떤 역할을 하는 지? → 게이트웨이로 보낼 때 유레카에 해당하는 이름이 등록되어있는지 확인해서 보냄 (round 방식)
    - 게이트웨이에서 라우팅할 때 어떻게 판단? → 유레카한테 받아와서 api 이름을 다 등록해서 식별
        - 게이트웨이에 부담감이 늘어날 듯 안그래도 바쁜데 → 사실 5분 정도 주기로 유레카에서 받아온 거를 캐싱해서 하도록 하고 있음 (별도의 설정을 안해도)
- 유레카가 왜 관리?
    - 클라우드니까 어떤 ip를 받을 지 모름 → ip가 고정인 유레카한테 보내는 게 나음
- 왜 모든 요청을 게이트웨이를 거쳐서 가야함?
    - 클라이언트의 모든 요청을 게이트웨이가 백엔드 앞단에서 처리함으로써 공통적인 응답처리가 가능
    - api가 서로 라우팅하면 복잡함 따라서 필요한 api를 게이트웨이가 라우팅하도록 처리하는 것이 편함

# 📍 개발 환경 구성

### ✔️ 데이터베이스 접속 정보 관리

- secure key manager 사용
    - 쓰는 이유? 깃에 올리면 ip port 정보가 다 보이기 때문에 → 보안 이슈

### ✔️ profile 분리

- prod, dev
- graceful shotdown → 30s 설정
- DBCP : 톰캣(200개)이 아니라 서버의 사양에 맞춰서 설정해야함 → 그런걸 고려해서 맞춰야함
- 커넥션 풀에 관련해 정리를 다시 … 해보세

### ✔️ log

- 중앙에서 로그 관리 → 서버 에러터질 때마다 직접 서버에 들어가서 보면 복잡함

# 📍JPA

### ✔️ Entity Manager

- 엔티티 매니저는 엔티티 매니저 팩토리가 생성함
- 엔티티 매니저는 언제 생성?
    - 트랜잭션을 수행할 때 생성 → 트랜잭션이 끝날 때
- 엔티티만 가져도 테이블이 생성 → 엔티티의 설정만 가지고 모든 관리가 불가능함
- 엔티티 그래프

# 📍 인증/인가

### ✔️ 인증

- jwt token은 base64 기반
- 토큰 기반의 인증하는 이유
    - 세션의 경우 다중 서버에서 적용하기 어려움 → 만약 적용하려면 세션 클러스터링을 이용해서 분산 서버에 동일하게 적용해야함
- 세션 기반의 인증 문제점

# 📍클라우드 환경

### ✔️ open feign client를 사용하는 이유?

- 유레카로부터 호출할려고 하는 api port나 ip를 받아와서 라우팅
- client side 클라이언트 쪽에서 api를 호출하더라도 스프링 클라우드 게이트웨이에서 라우팅되기 때문에 이건 server side가 된다….. 먼 소리징 ㅜ
- 클라이언트 내에서 라우팅
- 이걸 알아야 msa 프로젝트 기반을 했다고 말할 수 있음
- 아키텍쳐 흐름을 잘 정리해야한다.

# 📍기술

### ✔️ Elastic search

### ✔️ RabbitMQ를 안쓰면 비동기 처리가 안되나? 사용하는 이유는?

- 과도한 트래픽이 몰렸을 때

### ✔️ Cache를 사용하는 이유

- 자주 조회되는 데이터들을 반복적으로 DB를 접근하면 시간+비용 → 캐시로 저장해서 빠르게 가져올 수 있도록 처리
- 로컬 캐시 : Ehcache, JCache …
- 원격 캐시 : Redis
- 데이터 정보가 수정되면? → 저장된 캐시 삭제

# 📍 테스트

### ✔️ 통합테스트 , 단위테스트

- 통합테스트 : 모든 빈들을 다 생성해서 주입 → 스프링 코어 기반의 뭐가 만들어졌다… → application context가 생성됨 (실행 환경이 다 설정됨)
- 단위테스트 : 필요한 빈들만 생성해서 주입

### ✔️ Spring mvc 테스트

- 컨트롤러 테스트

### ✔️ Service 테스트

- Mock vs Spy ?
    - mock의 경우 모두 가짜 객체
    - spy는 부분 가짜..? ㅜㅜ

### ✔️JPA Repository 테스트

- @DataJpaTest → 엔티티 매니저를 사용하여 테스트